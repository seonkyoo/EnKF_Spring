<html>
<head>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script src="VectorNew.js"></script>
<script src="fn_EnKF.js"></script>
<script>

	// var context,canvas;
	var bodies  = [];    // Reference Two-body System (to observed)
	var bodiesEn = [];   // Ensemble of Two-body Systems
	var springs = [];    // Reference Spring (with true stiffness)
	var springsEn = [];  // Ensemble of Springs (with random stiffnesses)
	var gravity = 0;
	var stiffness = [1.2];
	var Ne = 20;		 // Number of Ensemble Members
	var stiffnessEn = [];// Initial Ensemble of Stiffness 
	for(var i=0; i<Ne; i++){
		stiffnessEn.push(Math.exp(randn_bm()));
	}
	var deltaT  = 0.1;
	var timer   = null;
	var alpha = 0.0;
	var clearFlag = 1;
	var R1 = (1+alpha*deltaT/2); 
	var R2 = (1-alpha*deltaT/2);
	var counter = 0;
	var radius = 5;

	// Gaussain variable generator using Box-Muller transform.
	function randn_bm() {
	    var u = 1 - Math.random(); // Subtraction to flip [0, 1) to (0, 1].
	    var v = 1 - Math.random();
	    return Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
	}

	window.onload=getCanvas;    
	function getCanvas(){
		canvas = document.getElementById("myCanvas");
		context=canvas.getContext("2d");
		DrawBox(0,0,canvas.width,canvas.height);
		bodies    = generateBodies(1,[600],[30]);

		var posX = []; var posY = [];
		for(var i = 0; i<Ne; i++){
			posX.push(200);
			posY.push(24*i+100);	
		}
		bodiesEn  = generateBodies(Ne,posX,posY);
		springs   = generateSprings(bodies,stiffness);
		springsEn = generateSprings(bodiesEn,stiffnessEn);
	}

	// Generate two-body systems as many as nSystem
	function generateBodies(nSystem,posX,posY){
		var bodiesReturn = [];
		for (var i=0; i<nSystem; i++){
			var bodiesTmp = [];
			bodiesTmp.push(Particle(Vector(posX[i],posY[i]),radius,Vector(0,0),Vector(0,0),1));
			bodiesTmp.push(Particle(Vector(posX[i]+100,posY[i]),radius,Vector(15,0),Vector(0,0),0));
			bodiesReturn.push(bodiesTmp);	
		}
		return bodiesReturn;
	}
	// Generate springs as many as the two-body systems
	function generateSprings(bodiesIn,stiffnessIn){
		var springsReturn = [];
		for(var i = 0;i<bodiesIn.length;i++){
			springsReturn.push(Spring(bodiesIn[i][0],bodiesIn[i][1],stiffnessIn[i]));
		}
		return springsReturn;
	}

	function updateParticles(){
		counter++;
		if(clearFlag == 1) context.clearRect(0, 0, canvas.width,canvas.height);
		DrawBox(0,0,canvas.width,canvas.height);
		bodies.forEach(function(bodiesOne){bodiesOne.forEach(zeroForce);});
		springs.forEach(updateSpringForces);
		bodies.forEach(function(bodiesOne){bodiesOne.forEach(updatePosition);});
		bodies.forEach(function(bodiesOne){bodiesOne.forEach(drawBody);});
		springs.forEach(drawSpring);

		bodiesEn.forEach(function(bodiesOne){bodiesOne.forEach(zeroForce);});
		springsEn.forEach(updateSpringForces);
		bodiesEn.forEach(function(bodiesOne){bodiesOne.forEach(updatePosition);});
		bodiesEn.forEach(function(bodiesOne){bodiesOne.forEach(drawBody);});
		springsEn.forEach(drawSpring);

		var x = [];
		for (var i = 0; i < Ne; i ++) {
			x[i] = Math.log(springsEn[i].stiffness);
		}

		var data = [
		  {
		    x: x,
		    type: 'histogram',
			marker: {
		    color: 'rgba(100,250,100,0.7)',
			},
		  }
		];
		Plotly.newPlot('histo', data);

	}

	function Particle(pos,radius,velocity,force,fixedFlag){
		return {pos:pos,radius:radius,velocity:velocity,
			force:force,fixedFlag:fixedFlag};
	}

	// A spring is updated by the motion of its particles
	// 2 particles passed in as parameters
	function Spring(p0,p1,stif){
	  	var masses = [p0,p1]; // masses = bodies
	   	var originalLength = p1.pos.minus(p0.pos).abs();
	   	
	  	return {masses:masses, originalLength:originalLength, stiffness: stif};
	}
	var updateSpringForces = function(spring){
	    var c0 = spring.masses[0].pos;
	    var c1 = spring.masses[1].pos;
	    var len1 = c1.minus(c0).abs();
	    var stif = spring.stiffness;
	    var forcemag = (len1 - spring.originalLength)*stif;

	    if(forcemag > 10) setDeleteSpring = spring;
	    var unitVec = c1.minus(c0).unit(); // unit vector along spring 

	    var f = unitVec.scale(forcemag);
	    spring.masses[0].force = spring.masses[0].force.plus(f);
	    spring.masses[1].force = spring.masses[1].force.minus(f);
	};
	var zeroForce = function(body){
		body.force = Vector(0,0);
	};
	var updatePosition = function(body){
			var mass = 1;
			if(body.fixedFlag === 0){
				body.velocity.x = 
					R2/R1*body.velocity.x + (deltaT/(2*R1))*body.force.x/(mass);
				body.velocity.y = 
					R2/R1*body.velocity.y + (deltaT/(2*R1))*(body.force.y/(mass)+gravity);

				body.pos.x += body.velocity.x*deltaT; // pos update
				body.pos.y += body.velocity.y*deltaT;
			}
			//checkWallCollision(body);
	};
	var checkWallCollision = function(body){
		if (body.pos.x + body.radius >= canvas.width ){
			body.velocity = Vector(-body.velocity.x,body.velocity.y);
		}
		if ((body.pos.x - body.radius) < 0){
			body.velocity = Vector(-body.velocity.x,body.velocity.y);
		}
		if (body.pos.y + body.radius >= canvas.height ){
			body.pos.y = canvas.height-body.radius;
			body.velocity = Vector(body.velocity.x,-body.velocity.y);
		}
		if (body.pos.y - body.radius < 0){
			body.velocity = Vector(body.velocity.x,-body.velocity.y);
		}
	};
	function drawBody(body){
		DrawCircle(body.pos.x,body.pos.y,body.radius);
	}
	function drawSpring(spring){
		DrawLine(spring.masses[0].pos,spring.masses[1].pos,spring.stiffness);
	}
	function DrawCircle(x,y,radius){
		context.fillStyle = 'rgba(255, 0, 0, .5)';
		context.beginPath();
		context.arc(x, y, radius, 0, Math.PI*2, true);
		context.closePath();
		context.fill();
	}
	function DrawBox(x,y,width,height){
		context.beginPath();
		context.rect(x,y,width,height);
		context.stroke();
		context.closePath();
	}
	function DrawLine(pos0,pos1,stif){
		context.font="15px Arial";
		context.fillText(stif.toString().slice(0,5),pos0.x-50,pos0.y+6);
		context.strokeStyle = 'rgba(0,255,0,0.1)'; // green
		context.lineWidth   = 2;
		context.beginPath();
		context.moveTo(pos0.x,pos0.y);
		context.lineTo(pos1.x,pos1.y);
		context.stroke();
		context.closePath();
	}


	// Start Button
	function RunPhysics(){
		timer = setInterval(updateParticles,100);
	}

	// Stop Button
	function ResetTimer(){
		if(timer!== null){
			clearInterval(timer); 
			timer = null;
		}
	}
	// Clear Button
	function Clear(){
		context.clearRect(0, 0, canvas.width,canvas.height);
		clearFlag *= -1;
	}
</script>
</head>
<body>
<div>
    <input type="button" value="Start" onclick= "RunPhysics()" />
    <input type="button" value="Stop"  onclick= "ResetTimer()" />
    <input type="button" value="Clear"  onclick= "Clear()" />
</div>
<div>
	<canvas id="myCanvas" width="800" height="600" > </canvas>
	<div id = "histo"></div>
</div>
</body>
</html>